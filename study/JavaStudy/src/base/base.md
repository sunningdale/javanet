java 基础
=========

**1，构造函数**

构造方法是一种特殊的方法，具有以下特点。
 - （1）构造方法的方法名必须与类名相同。
 - （2）构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。
 - （3）构造方法的主要作用是完成对象的初始化工作，它能够把定义对象时的参数传给对象的域。
 - （4）一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码。
 - （5）构造方法可以重载，以参数的个数，类型。但是，不区分参数的排列顺序。
 
**2,构造函数的继承**

- （1）子类只继承父类的默认(缺省)构造函数，即无形参构造函数。如果父类没有默认构造函数，那子类不能从父类继承到任何构造函数。
- （2）子类从父类处继承来的父类默认构造函数，不能成为子类的默认构造函数。
- （3）在创建对象时，先调用父类默认构造函数对对象进行初始化，然后调用子类自身自己定义的构造函数。
- （4）如果子类想调用父类的非默认构造函数，则必须使用super来实现。
- （5）子类必须调用父类的构造函数。可以通过系统自动调用父类的默认构造函数，如果父类没有默认构造函数时，子类构造函数必须通过super调用父类的构造函数。

**3,继承**
 父类又叫超类或基类，子类又叫派生类。父类是子类的一般化，子类是父类的特化（具体化）JAVA不支持多重继承
 - 继承关系是传递的
 - 继承提供了软件复用功能
 - 继承通过增强一致性来减少模块间的接口和界面，大大增加了程序的易维护性。
 - 提供多重继承机制。从理论上说，一个类可以是多个一般类的特殊类，它可以从多个一般类中继承属性与方法，这便是多重继承。Java出于安全性和可靠性的考虑，仅支持单重继承，而通过使用接口机制来实现多重继承。
 
  **父类的引用指向子类**
    
    - 定义一个父类类型的引用指向一个子类的对象既可以使用子类强大的功能，又可以抽取父类的共性。
    - 所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，它是无可奈何的；
    - 同时，父类中的一个方法只有在在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用；
    - 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。
    fg:base.extend.SonClass1

    **对于多态，可以总结它为**
    
    -  使用父类类型的引用指向子类的对象；
    - 该引用只能调用父类中定义的方法和变量；
    - 如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）
    - 变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。
   
   **总结** 

   1、通过将子类对象引用赋值给超类对象引用变量来实现动态方法调用。 

    DerivedC c2=new DerivedC(); 
    BaseClass a1= c2; //BaseClass 基类，DerivedC是继承自BaseClass的子类 
    a1.play(); //play()在BaseClass，DerivedC中均有定义，即子类覆写了该方法 

   分析： 
    * 为什么子类的类型的对象实例可以覆给超类引用？ 
       自动实现向上转型。通过该语句，编译器自动将子类实例向上移动，成为通用类型BaseClass； 
    * a.play()将执行子类还是父类定义的方法？ 
      子类的。在运行时期，将根据a这个对象引用实际的类型来获取对应的方法。所以才有多态性。一个基类的对象引用，被赋予不同的      子类对象引用，执行该方法时，将表现出不同的行为。 

      在a1=c2的时候，仍然是存在两个句柄，a1和c2，但是a1和c2拥有同一块数据内存块和不同的函数表。 

    2、不能把父类对象引用赋给子类对象引用变量 

       BaseClass a2=new BaseClass(); 
       DerivedC c1=a2;//出错 

       在java里面，向上转型是自动进行的,但是向下转型却不是，需要我们自己定义强制进行。 
       c1=(DerivedC)a2; 进行强制转化,也就是向下转型. 

    3、记住一个很简单又很复杂的规则，一个类型引用只能引用引用类型自身含有的方法和变量。 
       你可能说这个规则不对的，因为父类引用指向子类对象的时候，最后执行的是子类的方法的。 
       其实这并不矛盾，那是因为采用了后期绑定，动态运行的时候又根据型别去调用了子类的方法。而假若子类的这个方法在父类中并       没有定义，则会出错。
